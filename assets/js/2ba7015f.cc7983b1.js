"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1509],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>u});var i=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=i.createContext({}),p=function(e){var t=i.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",_={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(a),d=n,u=c["".concat(l,".").concat(d)]||c[d]||_[d]||r;return a?i.createElement(u,o(o({ref:t},m),{},{components:a})):i.createElement(u,o({ref:t},m))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:n,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,a)}d.displayName="MDXCreateElement"},1748:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>_,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var i=a(7462),n=(a(7294),a(3905));const r={},o="Metal, Dipole, and PML",s={unversionedId:"Tutorials/metal_dipole",id:"Tutorials/metal_dipole",title:"Metal, Dipole, and PML",description:"This tutorial is derived from this script.",source:"@site/docs/Tutorials/metal_dipole.md",sourceDirName:"Tutorials",slug:"/Tutorials/metal_dipole",permalink:"/fmmax/Tutorials/metal_dipole",draft:!1,editUrl:"https://github.com/facebookresearch/fmmax/docs/Tutorials/metal_dipole.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Introduction: simulating a periodic dipole",permalink:"/fmmax/Tutorials/dipoles"},next:{title:"Brillouin Zone Integration on a Photonic Crystal",permalink:"/fmmax/Tutorials/crystal_bz"}},l={},p=[{value:"Setting up the simulation",id:"setting-up-the-simulation",level:2},{value:"Compute Eigenmodes for each layer",id:"compute-eigenmodes-for-each-layer",level:2},{value:"Calculate the scattering matrices for each substack",id:"calculate-the-scattering-matrices-for-each-substack",level:2},{value:"Create a dipole source",id:"create-a-dipole-source",level:2}],m={toc:p},c="wrapper";function _(e){let{components:t,...r}=e;return(0,n.kt)(c,(0,i.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"metal-dipole-and-pml"},"Metal, Dipole, and PML"),(0,n.kt)("p",null,"This tutorial is derived from this ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/facebookresearch/fmmax/blob/main/examples/metal_dipole.py"},"script"),"."),(0,n.kt)("p",null,"This tutorial demonstrates how to simulate a dipole above a metal plane, surrounded by absorbing layers, using the ",(0,n.kt)("inlineCode",{parentName:"p"},"fmmax")," library. The presence of the metal plane modifies the radiated power from the dipole, leading to angular dependence in the emission pattern. A cross section of the simulation is depicted below."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"_____________________________\n|xxx|                   |xxx|\n|xxx|                   |xxx|   x: ambient, pml\n|xxx|                   |xxx|   y: metal, pml\n|xxx|        o <-dipole |xxx|   z: metal, no pml\n|xxx|___________________|xxx|\n|yyy|zzzzzzzzzzzzzzzzzzz|yyy|\n")),(0,n.kt)("h2",{id:"setting-up-the-simulation"},"Setting up the simulation"),(0,n.kt)("p",null,"First, let's establish the following simulation parameters\n(all lengths are in ",(0,n.kt)("em",{parentName:"p"},"microns")," (",(0,n.kt)("span",{parentName:"p",className:"math math-inline"},(0,n.kt)("span",{parentName:"span",className:"katex"},(0,n.kt)("span",{parentName:"span",className:"katex-mathml"},(0,n.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,n.kt)("semantics",{parentName:"math"},(0,n.kt)("mrow",{parentName:"semantics"},(0,n.kt)("mi",{parentName:"mrow"},"\u03bc"),(0,n.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"m")),(0,n.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mu\\mathrm{m}")))),(0,n.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,n.kt)("span",{parentName:"span",className:"base"},(0,n.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,n.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03bc"),(0,n.kt)("span",{parentName:"span",className:"mord mathrm"},"m"))))),")):"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import pml\n\n#The permittivity of the ambient.\npermittivity_ambient = (1.0 + 0.0j)\n#The permittivity of the metal.\npermittivity_metal = (-7.632 + 0.731j)\n#The distance between the dipole and the metal.\nthickness_dipole_metal_gap = 1.0\n#The thickness of the ambient above the dipole.\nthickness_ambient = 2.0\n#The thickness of the metal layer.\nthickness_metal = 0.1\n#The x- and y-extent of the unit cell.\npitch = 5.0\n#The shape of the grid used to represent permittivities and permeabilities.\ngrid_shape = (400, 400)\n#The spacing of grid points for calculated fields.\ngrid_spacing_fields = 0.01\n#The wavelength of dipole emission.\nwavelength = 0.63\n#The approximate number of terms used in the plane wave expansion of the fields.\napproximate_num_terms = 1200\n#Parameters specifying the extent and strength of the perfectly matched layers.\npml_params = pml.PMLParams(num_x=50, num_y=50)\n")),(0,n.kt)("p",null,"Now, we can generate the basis expansion. We also define a standard periodic boundary conditions with no extra Bloch phase."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from jax import numpy as jnp\nfrom fmmax import basis\n\nprimitive_lattice_vectors = basis.LatticeVectors(\n    u=pitch * basis.X, v=pitch * basis.Y\n)\nexpansion = basis.generate_expansion(\n    primitive_lattice_vectors=primitive_lattice_vectors,\n    approximate_num_terms=approximate_num_terms,\n    truncation=basis.Truncation.CIRCULAR,\n)\nin_plane_wavevector = jnp.zeros((2,))\n")),(0,n.kt)("p",null,"We're now going to generate an anisotropic permittivity and permeability, which are the outcomes of applying a uniaxial Perfectly Matched Layer (PML) to the x- and y-boundaries. The Fourier Modal Method (FMM), being a semi-analytic method, is capable of perfectly matching the infinite boundaries in the z-direction. Also note that the design of the PML is based on the assumption of a unit cell, where the primitive lattice vectors are perfectly aligned with the x- and y-directions."),(0,n.kt)("p",null,"The following code generates these properties for both the ambient and metal mediums, using the ",(0,n.kt)("inlineCode",{parentName:"p"},"apply_uniaxial_pml()")," function:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"permittivities_ambient_pml, permeabilities_ambient_pml = pml.apply_uniaxial_pml(\n    permittivity=jnp.full(grid_shape, permittivity_ambient),\n    pml_params=pml_params,\n)\npermittivities_metal_pml, permeabilities_metal_pml = pml.apply_uniaxial_pml(\n    permittivity=jnp.full(grid_shape, permittivity_metal),\n    pml_params=pml_params,\n)\n")),(0,n.kt)("h2",{id:"compute-eigenmodes-for-each-layer"},"Compute Eigenmodes for each layer"),(0,n.kt)("p",null,"FMMAX needs to solve for all the eigenmodes of each layer. Since the permittivies and permeabilities we just obtained are anisotropic, we must use the ",(0,n.kt)("inlineCode",{parentName:"p"},"fmm.eigensolve_general_anisotropic_media()")," function to obtain the eigenmodes."),(0,n.kt)("p",null,"The following snippet of code uses the ",(0,n.kt)("inlineCode",{parentName:"p"},"functools.partial()")," function from Python's standard library to create a new function eigensolve that behaves like the ",(0,n.kt)("inlineCode",{parentName:"p"},"fmm.eigensolve_general_anisotropic_media()")," function but with some of its arguments already filled in. This is to create a new function with a specific context or configuration. Another advantage of using ",(0,n.kt)("inlineCode",{parentName:"p"},"functools.partial()")," over lambda expressions or anonymous functions is that it provides better introspection capabilities, which can be particularly useful for debugging and tracing purposes within the context of JAX."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import fmm\nimport functools\n\neigensolve = functools.partial(\n    fmm.eigensolve_general_anisotropic_media,\n    wavelength=jnp.asarray(wavelength),\n    in_plane_wavevector=in_plane_wavevector,\n    primitive_lattice_vectors=primitive_lattice_vectors,\n    expansion=expansion,\n    formulation=fmm.Formulation.FFT,\n    vector_field_source=None,  # Automatically choose the vector field source.\n)\n")),(0,n.kt)("p",null,"Now that we have the information pre-filled in, we can start using this newly defined function ",(0,n.kt)("inlineCode",{parentName:"p"},"eigensolve()")," by passing in the permittivity and permeability information. We will keep track of the solve results separately for the eigenmodes above (",(0,n.kt)("inlineCode",{parentName:"p"},"solve_result_ambient"),") and below (",(0,n.kt)("inlineCode",{parentName:"p"},"solve_result_method"),") the source."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"solve_result_ambient = eigensolve(\n    permittivity_xx=permittivities_ambient_pml[0],\n    permittivity_xy=permittivities_ambient_pml[1],\n    permittivity_yx=permittivities_ambient_pml[2],\n    permittivity_yy=permittivities_ambient_pml[3],\n    permittivity_zz=permittivities_ambient_pml[4],\n    permeability_xx=permeabilities_ambient_pml[0],\n    permeability_xy=permeabilities_ambient_pml[1],\n    permeability_yx=permeabilities_ambient_pml[2],\n    permeability_yy=permeabilities_ambient_pml[3],\n    permeability_zz=permeabilities_ambient_pml[4],\n)\nsolve_result_metal = eigensolve(\n    permittivity_xx=permittivities_metal_pml[0],\n    permittivity_xy=permittivities_metal_pml[1],\n    permittivity_yx=permittivities_metal_pml[2],\n    permittivity_yy=permittivities_metal_pml[3],\n    permittivity_zz=permittivities_metal_pml[4],\n    permeability_xx=permeabilities_metal_pml[0],\n    permeability_xy=permeabilities_metal_pml[1],\n    permeability_yx=permeabilities_metal_pml[2],\n    permeability_yy=permeabilities_metal_pml[3],\n    permeability_zz=permeabilities_metal_pml[4],\n)\n")),(0,n.kt)("h2",{id:"calculate-the-scattering-matrices-for-each-substack"},"Calculate the scattering matrices for each substack"),(0,n.kt)("p",null,"We are now prepared to compute the scattering matrices (s-matrices). These matrices define the relationship between the forward- and backward-propagating eigenmodes within each layer. The FMMAX library offers a variety of routines for this purpose, each with varying degrees of abstraction."),(0,n.kt)("p",null,"In this specific context, our objective is to independently compute the s-matrices for two distinct portions (substacks): the upper (ambient) and the lower (from the dipole to the metal gap, and the metal itself). Instead of merging the layers at this point, we strategically place our dipole source between these two portions. This method allows us to associate the dipole source with the corresponding s-matrices of each portion."),(0,n.kt)("p",null,"The following code illustrates this procedure:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import scattering\n\n# Compute interior scattering matrices to enable field calculations.\ns_matrices_interior_before_source = scattering.stack_s_matrices_interior(\n    layer_solve_results=[solve_result_ambient],\n    layer_thicknesses=[jnp.asarray(thickness_ambient)],\n)\ns_matrices_interior_after_source = scattering.stack_s_matrices_interior(\n    layer_solve_results=[solve_result_ambient, solve_result_metal],\n    layer_thicknesses=[\n        jnp.asarray(thickness_dipole_metal_gap),\n        jnp.asarray(thickness_metal),\n    ],\n)\n")),(0,n.kt)("h2",{id:"create-a-dipole-source"},"Create a dipole source"),(0,n.kt)("p",null,"We are now ready to create our dipole source, which is periodically located at the center of our unit cell. First, we use the ",(0,n.kt)("inlineCode",{parentName:"p"},"sources.dirac_delta_source()")," to expand the dipole into superpositions of planewaves. Then, we want the source to propagate in both directions, upwards and downwards as an 'embedded source'."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import sources\n\n# Generate the Fourier representation of a point dipole.\ndipole = sources.dirac_delta_source(\n    location=jnp.asarray([[pitch / 2, pitch / 2]]),\n    in_plane_wavevector=in_plane_wavevector,\n    primitive_lattice_vectors=primitive_lattice_vectors,\n    expansion=expansion,\n)\n")),(0,n.kt)("p",null,"Before we can calculate the amplitudes of the dipole source, we must obtain the s-matrices relating fields at the two ends of each substack. We obtained this information earlier using the function ",(0,n.kt)("inlineCode",{parentName:"p"},"scattering.stack_s_matrices_interior()"),". This function returns a ",(0,n.kt)("inlineCode",{parentName:"p"},"Tuple")," of s-matrix substacks where each substack is a ",(0,n.kt)("inlineCode",{parentName:"p"},"Tuple")," of individual s-matrix corresponding to the different layers."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"s_matrix_before_source = s_matrices_interior_before_source[0][0]\ns_matrix_after_source = s_matrices_interior_after_source[-1][0]\n")),(0,n.kt)("p",null,"We have now all the information needed to propagate the dipole source into the top and bottom substacks. The ",(0,n.kt)("inlineCode",{parentName:"p"},"sources.amplitudes_for_source()")," function will properly convert the dipole electric current sources to the corresponding Fourier field amplitudes and propagate them along both directions (top and bottom in this context)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"# Compute backward eigenmode amplitudes at the end of the layer before the\n# source, and the forward amplitudes the start of the layer after the source.\n(\n    _,\n    _,\n    bwd_amplitude_before_end,\n    fwd_amplitude_after_start,\n    _,\n    _,\n) = sources.amplitudes_for_source(\n    jx=jnp.zeros_like(dipole),\n    jy=dipole, # Only excite the y polarization.\n    jz=jnp.zeros_like(dipole),\n    s_matrix_before_source=s_matrix_before_source,\n    s_matrix_after_source=s_matrix_after_source,\n)\n")),(0,n.kt)("p",null,"With the forward and backward propagating Fourier field amplitudes calculated, we can use these amplitudes to excite the eigenmodes we previously calculated given the scattering matrices before (",(0,n.kt)("inlineCode",{parentName:"p"},"s_matrix_before_source"),") and after ( ",(0,n.kt)("inlineCode",{parentName:"p"},"s_matrix_after_source"),") the source. The function we use here is called ",(0,n.kt)("inlineCode",{parentName:"p"},"fields.stack_amplitudes_interior_with_source()"),", which returns the forward- and backward-propagating wave amplitude for each layer."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import fields\n\n# Solve for the eigenmode amplitudes in every layer of the stack.\namplitudes_interior = fields.stack_amplitudes_interior_with_source(\n    s_matrices_interior_before_source=s_matrices_interior_before_source,\n    s_matrices_interior_after_source=s_matrices_interior_after_source,\n    backward_amplitude_before_end=bwd_amplitude_before_end,\n    forward_amplitude_after_start=fwd_amplitude_after_start,\n)\n")),(0,n.kt)("h1",{id:"visualization"},"Visualization"),(0,n.kt)("p",null,"Thus far, we have obtained the s-matrices and the propagating wave amplitudes for each layer. We can use a function called ",(0,n.kt)("inlineCode",{parentName:"p"},"fields.stack_fields_3d_on_coordinates()")," to convert that into a cartesian 3d vector field to visualize. We can take a 2d cross section by specifying the x coordinates to span across the entire period, while keeping the y coordinates constant."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"# Coordinates where fields are to be evaluated.\nx = jnp.linspace(0, pitch, grid_shape[0])\ny = jnp.ones_like(x) * pitch / 2\n(ex, ey, ez), (hx, hy, hz), (x, y, z) = fields.stack_fields_3d_on_coordinates(\n    amplitudes_interior=amplitudes_interior,\n    layer_solve_results=[\n        solve_result_ambient,\n        solve_result_ambient,\n        solve_result_metal,\n    ],\n    layer_thicknesses=[\n        jnp.asarray(thickness_ambient),\n        jnp.asarray(thickness_dipole_metal_gap),\n        jnp.asarray(thickness_metal),\n    ],\n    layer_znum=[\n        int(thickness_ambient / grid_spacing_fields),\n        int(thickness_dipole_metal_gap / grid_spacing_fields),\n        int(thickness_metal / grid_spacing_fields),\n    ],\n    x=x,\n    y=y,\n)\n")),(0,n.kt)("p",null,"Let's visualize the amplitude of the electric field now!"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},'import matplotlib.pyplot as plt\n\nfield_3d = jnp.sqrt(jnp.abs(ex) ** 2 + jnp.abs(ey) ** 2 + jnp.abs(ez) ** 2)\nfield_plot = field_3d[:, :, 1]\n\nxplot, zplot = jnp.meshgrid(x, z, indexing="ij")\n\nplt.figure(figsize=(float(jnp.amax(xplot)), float(jnp.amax(zplot))), dpi=80)\nax = plt.subplot(111)\nim = ax.pcolormesh(xplot, zplot, field_plot, shading="nearest", cmap="magma")\n\n# Clip the color scale to the 99.8th percentile of the field.\nclip_percentile = 99.8\nclipval = float(jnp.percentile(field_plot, clip_percentile))\nim.set_clim((0, clipval))\n\nax.axis("equal")\nax.axis("off")\nax.set_ylim(ax.get_ylim()[::-1])\n\nplt.subplots_adjust(left=0, bottom=0, right=1, top=1)\nplt.show()\n')),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"png",src:a(2842).Z,width:"1486",height:"1490"})),(0,n.kt)("p",null,'As you can see, the plot above shows a clear view of the PML on the sides, as it the attenuates the dipole amplitudes with minimal back reflections. The metal plane is also visible beneath the dipole. It\'s worth noting that the dipole is has a finite width, and thus utilizing more Fourier terms can improve the resolution of an actual "delta function" point source (as demonstrated in the ',(0,n.kt)("a",{parentName:"p",href:"https://facebookresearch.github.io/fmmax/Tutorials/dipoles"},"previous tutorial"),")."))}_.isMDXComponent=!0},2842:(e,t,a)=>{a.d(t,{Z:()=>i});const i=a.p+"assets/images/output_23_0-c28eee0fb289fce12e1bbe398ab380f9.png"}}]);