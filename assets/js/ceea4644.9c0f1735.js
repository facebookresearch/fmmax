"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2729],{3905:(t,n,e)=>{e.d(n,{Zo:()=>p,kt:()=>_});var r=e(7294);function a(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function i(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function o(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?i(Object(e),!0).forEach((function(n){a(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function m(t,n){if(null==t)return{};var e,r,a=function(t,n){if(null==t)return{};var e,r,a={},i=Object.keys(t);for(r=0;r<i.length;r++)e=i[r],n.indexOf(e)>=0||(a[e]=t[e]);return a}(t,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)e=i[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(a[e]=t[e])}return a}var s=r.createContext({}),l=function(t){var n=r.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):o(o({},n),t)),e},p=function(t){var n=l(t.components);return r.createElement(s.Provider,{value:n},t.children)},c="mdxType",u={inlineCode:"code",wrapper:function(t){var n=t.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(t,n){var e=t.components,a=t.mdxType,i=t.originalType,s=t.parentName,p=m(t,["components","mdxType","originalType","parentName"]),c=l(e),f=a,_=c["".concat(s,".").concat(f)]||c[f]||u[f]||i;return e?r.createElement(_,o(o({ref:n},p),{},{components:e})):r.createElement(_,o({ref:n},p))}));function _(t,n){var e=arguments,a=n&&n.mdxType;if("string"==typeof t||a){var i=e.length,o=new Array(i);o[0]=f;var m={};for(var s in n)hasOwnProperty.call(n,s)&&(m[s]=n[s]);m.originalType=t,m[c]="string"==typeof t?t:a,o[1]=m;for(var l=2;l<i;l++)o[l]=e[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,e)}f.displayName="MDXCreateElement"},9533:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>m,toc:()=>l});var r=e(7462),a=(e(7294),e(3905));const i={id:"metal_grating"},o="Metal Grating",m={unversionedId:"Tutorials/metal_grating",id:"Tutorials/metal_grating",title:"Metal Grating",description:"The full script can be found here.",source:"@site/docs/Tutorials/metal_grating.md",sourceDirName:"Tutorials",slug:"/Tutorials/metal_grating",permalink:"/fmmax/Tutorials/metal_grating",draft:!1,editUrl:"https://github.com/facebookresearch/fmmax/docs/Tutorials/metal_grating.md",tags:[],version:"current",frontMatter:{id:"metal_grating"}},s={},l=[],p={toc:l},c="wrapper";function u(t){let{components:n,...e}=t;return(0,a.kt)(c,(0,r.Z)({},p,e,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"metal-grating"},"Metal Grating"),(0,a.kt)("p",null,"The full script can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebookresearch/fmmax/blob/main/examples/metal_grating.py"},"here"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'resolution_nm: float = 1.0 # The rasterization resolution for patterned layers.\npitch_nm: float = 180.0 # The grating pitch, in nanometers.\ngrating_width_nm: float = 60.0 # The width of the lines comprising the grating.\n\nx_nm, _ = jnp.meshgrid(\n    jnp.arange(-pitch_nm / 2, pitch_nm / 2, resolution_nm),\n    jnp.arange(-pitch_nm / 2, pitch_nm / 2, resolution_nm),\n    indexing="ij",\n)\ndensity = (jnp.abs(x_nm) <= grating_width_nm / 2).astype(float)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import utils\n\npermittivity_ambient: complex = 1.0 + 0.0j # The permittivity of the ambient.\npermittivity_planarization: complex = 2.25 + 0.0j # The permittivity of media encapsulating grating.\npermittivity_substrate: complex = -7.632 + 0.731j # The permittivity of the substrate below the grating\n\npermittivities = [\n    jnp.asarray([[permittivity_ambient]]),\n    jnp.asarray([[permittivity_planarization]]),\n    utils.interpolate_permittivity(\n        permittivity_solid=jnp.asarray(permittivity_substrate),\n        permittivity_void=jnp.asarray(permittivity_planarization),\n        density=density,\n    ),\n    jnp.asarray([[permittivity_substrate]]),\n]\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"planarization_thickness_nm: float = 20.0\ngrating_thickness_nm: float = 80.0 # The height of the grating.\n\nthicknesses = [0, planarization_thickness_nm, grating_thickness_nm, 0]\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"in_plane_wavevector = jnp.asarray([0.0, 0.0])\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"primitive_lattice_vectors = basis.LatticeVectors(\n    u=jnp.asarray([pitch_nm, 0.0]), v=jnp.asarray([0.0, pitch_nm])\n)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import basis\n\napproximate_num_terms: int = 20\ntruncation: basis.Truncation = basis.Truncation.CIRCULAR\n\nexpansion = basis.generate_expansion(\n    primitive_lattice_vectors=primitive_lattice_vectors,\n    approximate_num_terms=approximate_num_terms,\n    truncation=truncation,\n)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import fmm\n\nformulation: fmm.Formulation = fmm.Formulation.FFT\nwavelength_nm: float = 500.0 # The excitation wavelength, in nanometers.\n\nlayer_solve_results = [\n    fmm.eigensolve_isotropic_media(\n        wavelength=jnp.asarray(wavelength_nm),\n        in_plane_wavevector=in_plane_wavevector,\n        primitive_lattice_vectors=primitive_lattice_vectors,\n        permittivity=p,\n        expansion=expansion,\n        formulation=formulation,\n    )\n    for p in permittivities\n]\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from fmmax import scattering\n\ns_matrix = scattering.stack_s_matrix(\n    layer_solve_results=layer_solve_results,\n    layer_thicknesses=[jnp.asarray(t) for t in thicknesses],\n)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"r_te = s_matrix.s21[0, 0]\nr_tm = s_matrix.s21[expansion.num_terms, expansion.num_terms]\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\ndef convergence_study(\n    approximate_num_terms: Tuple[int, ...] = NUM_TERMS_SWEEP,\n    truncations: Tuple[basis.Truncation, ...] = (\n        basis.Truncation.CIRCULAR,\n        basis.Truncation.PARALLELOGRAMIC,\n    ),\n    fmm_formulations: Tuple[fmm.Formulation, ...] = (\n        fmm.Formulation.FFT,\n        fmm.Formulation.JONES_DIRECT,\n        fmm.Formulation.JONES,\n        fmm.Formulation.NORMAL,\n        fmm.Formulation.POL,\n    ),\n) -> Tuple[Tuple[fmm.Formulation, basis.Truncation, int, complex, complex], ...]:\n    """Sweeps over number of terms and fmm formulations to study convergence."""\n    results = []\n    for formulation, truncation, n in itertools.product(\n        fmm_formulations,\n        truncations,\n        approximate_num_terms,\n    ):\n        num_terms, r_te, r_tm = simulate_grating(\n            approximate_num_terms=n,\n            truncation=truncation,\n            formulation=formulation,\n        )\n        results.append((formulation, truncation, num_terms, r_te, r_tm))\n        print(\n            f"{formulation.value}/{truncation.value}/n={num_terms}: "\n            f"r_te={complex(r_te):.3f}, r_tm={complex(r_tm):.3f}"\n        )\n    return tuple(results)\n')))}u.isMDXComponent=!0}}]);