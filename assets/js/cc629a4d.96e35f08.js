"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8688],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,f=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return n?r.createElement(f,a(a({ref:t},u),{},{components:n})):r.createElement(f,a({ref:t},u))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:i,a[1]=l;for(var c=2;c<o;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7010:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(7462),i=(n(7294),n(3905));const o={id:"vector.compute_tangent_field"},a=void 0,l={unversionedId:"API/vector.compute_tangent_field",id:"API/vector.compute_tangent_field",title:"vector.compute_tangent_field",description:"vector.computetangentfield",source:"@site/docs/API/vector.compute_tangent_field.md",sourceDirName:"API",slug:"/API/vector.compute_tangent_field",permalink:"/fmmax/API/vector.compute_tangent_field",draft:!1,editUrl:"https://github.com/facebookresearch/fmmax/docs/API/vector.compute_tangent_field.md",tags:[],version:"current",frontMatter:{id:"vector.compute_tangent_field"},sidebar:"APISidebar",previous:{title:"vector.compute_gradient",permalink:"/fmmax/API/vector.compute_gradient"},next:{title:"vector.field_loss_value_jac_and_hessian",permalink:"/fmmax/API/vector.field_loss_value_jac_and_hessian"}},s={},c=[{value:"<code>vector.compute_tangent_field</code>",id:"vectorcompute_tangent_field",level:3},{value:"Args:",id:"args",level:4},{value:"Returns:",id:"returns",level:4}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"vectorcompute_tangent_field"},(0,i.kt)("inlineCode",{parentName:"h3"},"vector.compute_tangent_field")),(0,i.kt)("p",null,"Compute the tangent vector field for ",(0,i.kt)("inlineCode",{parentName:"p"},"arr"),"."),(0,i.kt)("p",null,"The calculation finds the minimum of a quadratic loss function using a single\nNewton iteration. Rather than optimizing the real-space tangent field, the\nFourier coefficients are directly optimized."),(0,i.kt)("p",null,"The tangent field has several properties or invariances:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The tangent field is independent of the scale of the unit cell; if the\nunit cell is uniformly scaled (e.g. by changing units from nm to microns),\nthe vector field is unchanged."),(0,i.kt)("li",{parentName:"ul"},"The tangent field for a supercell (containing e.g. 2x2 unit cells) is\nidentical to that of a single unit cell, so long as the number of terms in\nthe Fourier expansion is increased correspondingly. Note that this means that\nthe tangent field depends upon the number of terms in the Fourier expansion."),(0,i.kt)("li",{parentName:"ul"},"The tangent field is independent of the resolution of the discretized unit\ncell. That is, whether the permittivity distribution is specified with a\n",(0,i.kt)("inlineCode",{parentName:"li"},"(100, 100)")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"(200, 200)")," shaped array has no impact on the resulting field."),(0,i.kt)("li",{parentName:"ul"},"The tangent field is independent of the amplitude of the array from which it is\nobtained, e.g. the permittivity contrast.")),(0,i.kt)("h4",{id:"args"},"Args:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"arr"),": The array for which the normal vector field is sought."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"expansion"),": The Fourier expansion for which the field is to be optimized."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"primitive_lattice_vectors"),": Define the unit cell coordinates."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"use_jones_direct"),": Specifies whether the complex Jones field is to be sought."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"fourier_loss_weight"),": Determines the weight of the loss term penalizing\nFourier terms corresponding to high frequencies. Should be positive."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"smoothness_loss_weight"),": Determines the weight of the loss term rewarding\nsmoothness of the tangent field in real space. Should be positive."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"steps"),": The number of Newton iterations to carry out. Generally, the default\nsingle iteration is sufficient to obtain converged fields.")),(0,i.kt)("h4",{id:"returns"},"Returns:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"None"),": The normal field, ",(0,i.kt)("inlineCode",{parentName:"li"},"(tx, ty)"),".")))}d.isMDXComponent=!0}}]);